<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>继承 on CayChance の Blog</title>
    <link>https://caychance.github.io/tags/%E7%BB%A7%E6%89%BF/</link>
    <description>Recent content in 继承 on CayChance の Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Thu, 13 Dec 2018 20:31:20 +0000</lastBuildDate>
    
	<atom:link href="https://caychance.github.io/tags/%E7%BB%A7%E6%89%BF/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>js继承方法总结</title>
      <link>https://caychance.github.io/posts/js%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 13 Dec 2018 20:31:20 +0000</pubDate>
      
      <guid>https://caychance.github.io/posts/js%E7%BB%A7%E6%89%BF%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</guid>
      <description>js继承方法  原型链继承 借用构造函数继承 组合继承 原型式继承 寄生式继承 寄生组合式继承 混入方式继承多个对象 ES6类继承extends 总结  原型链继承 构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。
 继承的本质就是复制，即重写原型对象，代之以一个新类型的实例。
 function Father() { this.property = true; } Father.prototype.getSuperValue = function() { return this.property; } function Son() { this.sonProperty = false; } // 这里是关键，创建Father的实例，并将该实例赋值给Son.prototype Son.prototype = new Father(); Son.prototype.getSubValue = function() { return this.sonProperty; } var instance = new Son(); console.log(instance.getSuperValue()); // true  原型链方案存在的缺点：
 多个实例对引用类型的操作会被篡改。  function Father(){ this.colors = [&amp;#34;red&amp;#34;, &amp;#34;blue&amp;#34;, &amp;#34;green&amp;#34;]; } function Son(){} Son.</description>
    </item>
    
  </channel>
</rss>